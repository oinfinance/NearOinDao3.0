# Hello. NEAR. OinDao.

```
  发现一个问题，合约不论由谁发布，初次发布的 env::predecessor_account_id 都是合约本身
  每个代币都需要用户去注册
```

- 每份 OinStake 都需要手动配置 token 和 coin 的
  也可以自动创建交易对，但是需要一份发布合约，去记录他们之间的关系
  OinStake 的管理权限无法转移

- 发布合约，首先管理 OinStake 和 Usdo、Oin 的关系，然后是进行喂价
- 后续操作流程就一样了

- OinStake 的代币存储，由项目方额外触发，必然再调用方法的时候进行 storage 和 xx 的计算

```
清算线 		   200%
满足质押线 	    700%
年化稳定费率 	0.5%
```

### 主业务逻辑

```
- 存入的业务逻辑
		系统关闭无法存入
		存入数量没有限制
		存入的时候计算 token奖励(利息)
			个人 token 增加
			系统 token 增加
		以上任何一环节出错，返回存入的 token 数字

- 铸出USDO业务
		系统关闭的时候无法铸出USDO
		没有喂价无法铸出
		不满足 系统质押率 和 个人质押率 无法铸出
			更新系统与个人的稳定费
			将对应的usdo发送给用户
			系统和个人记录铸出的usdo

- 归还USDO业务
		系统关闭无法归还业务
		没有喂价无法归还
		销毁的时候按质押比率销毁
		销毁数量必须小于用户实际铸出数量
		系统和个人记录销毁的usdo

- 提取的业务逻辑
		系统非关闭，满足系统与个人质押率
		计算可提取数量，然后必须小于这个数值
		系统和个人记录 token 数量

系统的质押率仅对清算线有效，个人质押率会限制个人的一些行为操作
	这里面是都要算入稳定费的计算，稳定费会多少，但是偏差不会太大
```

### 限制

```
NEAR 里面将存储占用的额度与质押 NEAR 联系起来，需要手动调整给开发造成了不必要的考虑
所以我这边的方案 => 使用频率少的要求调用者主动转账给合约账户
				 且一旦存入就相当于以太坊的GAS消耗，不提供退出机制
```

### 精度

```
	stable_rate  	16_bit
	coin	 		8_bit
	token	 		24_bit

	由于精度的问题，全局的稳定费仅作展示标的作用，不具有实际意义
	具体的稳定费收取还是根据个人用户计算以及支付的为准
	已支付的稳定费会记录在系统中 => 这一部分才具有实际意义
```

### 清算

```
清算之后，不计算生息奖励 和 稳定费
```

```
当下有一个问题需要测试下
	就是主动 transfer NEAR 之后，在程序执行失败会不会把这部分NEAR 返回
```

### 公式

```
	质押率 = 质押个数 * 代币价格 / 1美刀  { 价值 }
	stake_rate 其实就是一个指标，其他时候用cost来进行计算


```

### 当前版本份合约

```
testnet => oinstake-1622450914.buddy.testnet
```
